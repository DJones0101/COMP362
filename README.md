# COMP362
Projects and Labs from 362

Lab 02 

 Question 1
5 / 5 pts
In this task you will be debugging the attached file (coredump.cPreview the document) using the following steps:

    Setting up the debugging process.
    Compiling the program.
    Running the code.
    Using the debugger.
    Fixing the problem.
    Testing.
    Removing cores.

Setting up the debugging process:

First make sure our operating system generates cores.
A core is an image of the state of a crashed program.
To make sure cores are generated, do the following command:

$ ulimit -c unlimited
Compiling the program:

To see the state of variables in the debugger, you will need to compile the program using the -g option.
This generates a debug version of the code that includes the symbol table.
To compile the code with this option, run the following command:

$ gcc -g coredump.c -o coredump
Running the code:

Use the following command to run the compiled program:

$ ./coredump
The next line will cause core dump.
Floating point exception (core dumped)
Using the debugger:

In complex programs a trace can be extremely helpful in finding the cause of the crash.
When gdb is run on a core, it recreates the execution environment at the time of the crash.

$ gdb coredump core

GNU gdb 6.3.50-20050815 (Apple version gdb-960) (Sun May 18 18:38:33 UTC 2008)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB. Type "show warranty" for details.
This GDB was configured as "i386-apple-darwin"...Reading symbols for shared libraries ... done
Core was generated by `./coredump'.
Reading symbols for shared libraries . done
Reading symbols for shared libraries ... done
#0 0x00001fbd in offensiveFunc (x=3, y=0) at coredump.c:13
13 int z = x / y;
Displaying the call stack:

(gdb) where
Viewing the code:

(gdb) list
8 return 0;
9 }
10
11 int offensiveFunc(int x, int y)
12 {
13 int z = x / y;
14 return z;
15 }
Examining local variables:

(gdb) print y
$1 = 0
(gdb) print x
$2 = 3
Fixing the problem:

By using the debugger we now have located the problem.
Now make the code safe so that it can handle the denominator being zero without crashing.
Do NOT just change the inputs to the function in main.
Making the code safe is different from just making the program not crash on one run.
Testing:

Run the code several times, changing the input values in main each time.
Make sure that if the denominator is zero the program does not crash.
Removing cores:

When you are not developing programs you may wish to set the core size limit back to 0 using:

$ ulimit -c 0
Submit in a zip file:

    A typescript showing each of the above steps.
    A safe version of the attached code.

 

 
Question 2
13 / 15 pts
The Task:

    Download this C program (crash.cPreview the document)
    Compile with debugging information using the "-g" option.
    Ensure core dumps are enabled.
    Use gdb breakpoints to locate the problem causing the code to crash.
    Fix the code.

Submit in a zip file:

    A typescript showing each of the above steps.
    A safe version of the attached code.

DariusJonesLab2Task2.zip
Do not used fixed size malloc's when the size of the thing you are mallocing can be easily determined.
 
Question 3
78 / 80 pts

For this task you will be writing a C system utility that meets the following attributes:
Base Code:

 
int main(int argc, char **argv) {
 char replaced_char;
 char replacement_char;
 // SECTION 1:
 // Setting up replaced_char and replacement_char
 // Check that there are at least the minimum number of arguments
 if (0) {
 // Get replaced_char and replacement_char from argv.
 replaced_char = 'a';
 replacement_char = 'b';
 //SECTION 2:
 // Process the remaining arguments (if any)
 // Use a while loop to process any input or output file arguments using freopen.
 // Be sure to check whether freopen was successful.
 while (0) {

 }
 } else {
 // Otherwise print the usage.
 
 }
 // SECTION 3:
 // Use a while loop to process the entire input stream and perform the main substitution functionality.
 while (0) {

 }
 // SECTION 4:
 // Close the input and output streams.
}

Utility Name:

sub - substitute character
Usage:

sub replaced_char replacement_char [-f input_file] [-o output_file]
Description:

sub copies from an input stream to an output stream replacing every instance of a specific character (replaced_char) with another provided character (replacement_char).
Options:

    -f (followed by input file name) Use a provided file as an input stream instead of standard input
    -o (followed by output file name) Use a provided file as an output stream instead of standard output
    -h prints the following message:

    sub replaced_char replacement_char [-f input_file] [-o output_file]

Files:

sub.c
Diagnostics (Error Messages):

    If replaced_char or replacement_char are missing print the usage information.
    If the "-o" or "-f" flags are used but no filename is provided also print the help information.
    If a file name is given but an error is encountered with that file a different error message should be printed.

Installation:

    Edit the "~/.bash_profile" file using vi, emacs, or a text editor to add the following command:

    PATH = $HOME/bin:$PATH
    Check that this was successful by running:

    $ set | grep PATH
    Copy the executable of your compiled sub program into the "~/bin" directory.
    The "sub" command should now work from any directory just like "cat" or "ls".

Examples:

    $ sub -h
    sub replaced_char replacement_char [-f inputFile] [-o outputFile]

    This displays the help information for the function.

    $ sub x y -f src.txt -o dest.txt

    This copies the content of src.txt to dest.txt with the exception that all instances of "x" are now replaced by "y".

    $ sub a b -f src.txt

    This will print the content of src.txt to the standard output with the exception that all instances of "a" will print as "b".

    $ sub b c -o dest.txt

    This will copy user input from standard input to dest.txt with the exception that all instances of "b" will be copied to dest.txt as "c".

    $ sub a z

    This will print user input from standard input to standard output with the exception that all instances of "a" will be printed as "z".

    $ sub x y < /myPath/myInputFile.txt

    This will print input from standard input (being piped in from myInputFile.txt) to standard output with the exception that all instances of "x" will be printed as "y".

    $ sub 1 d < /myPath/myInputFile.txt > /myPath/myOutputFile.txt
    This will print input from standard input (being piped in from myInputFile.txt) to standard output (being piped to myOutputFile.txt) with the exception that all instances of "1" will be printed as "d".

Important Notes:

    You must use freopen to switch the input/output streams in the case of -f or -o flags.
    Process the arguments dynamically in any order (i.e. not if argc == 2 ... 3... or switch statements) Use a for loop or a while loop.
    Test your program on different inputs with different letters being replaced, don't use files such as "aaaa"

Submit in a zip file:

    A typescript showing you run some variation of each of those example commands.
    Your sub.c file

Lab 03 

 Question 1
10 / 10 pts

Your task is to create a hierarchy of labelled tags using forks.

    Download proc_hier.zip.
    Edit the provided code to create the hierarchy
    Use the debugger to trace the execution of your program.

Creating the Hierarchy:

You will be creating a three level hierarchy of processes with a total of seven tags:

    "1" The root process.
        "1.1.1" The first child of "1.1".
        "1.1.2" The second child of "1.1".
        "1.2.1" The first child of "1.2".
        "1.2.2" The second child of "1.2".
        "1.1" The first child of "1".
        "1.2" The second child of "1".

Tags are created by passing the appropriate string to the function in iam.c.
Debugging with fork():

The gdb debugger has facilities for debugging programs that use fork() and exec()-family of functions. These facilities require assistance from the operating system. There are two flags that control how gdb traces code; use the following to get the details:

gdb> help set follow-fork-mode
gdb> help set follow-exec-mode

The gdb also provides access to the information about so-called inferiors; that is, the entities that are debugged:

gdb> info inferiors

Submit your modified C files along with the logs from debugging sessions that show a trace of execution into the child "1.2.2", and then on into the iam program.

You may start the debugger and attach it to a running process. That is why iam.c has an infinite loop: to give you a chance to attach to it when it's spawned from proc_hier. After running proc_hier, find out what are process ids of all the spawned iam processes as follows:

$ ps | grep iam

Then, run your gdb (you may need to do that with sudo):

$ sudo gdb -p <process id> iam
DariusJonesLab3Task1.zip
 
Question 2
15 / 15 pts
Your Task:

pipe.c currently sends fixed strings between a parent process and its child.
Your task is to implement the following:
Parent Process:

In a loop:

    Prompts the user to provide text that will be sent to the child process.
    Should receive and then print a message back from the child in the form of:
    "RECEIVED <message>"
    When the message received is "STOPPING" the parent should break out of the loop.

Waits for the child to terminate, then terminates as well.
Child Process:

In a loop:

    Receives and prints messages from the parent until "STOP" is received.
    When "STOP" is received, child should respond with "STOPPING" and then terminate.
    Messages other than "STOP" should be sent back to the parent in the form of:
    "RECEIVED <message>"

Helpful Resources:

You may try to use elements of the following code:

char buf[BUFSIZ];

...

while ( fgets(buf, BUFSIZ, stdin) ...

As always, using man might be helpful:

$ man fgets



DariusJonesLab3Task2.zip
Nice I/O though the order sometimes got jumbled, but it was easy to see what was happening.
 
Question 3
15 / 15 pts
Your Task:

Combine the two programs in npipe.zip and add the functionality contained in the following description.

The resulting program should have two modes:
Sending:

The programs mode should be set to Sending if the program checks for the fifo and it does not exist.

Once set to Sending mode the program should:

    Create the fifo queue.
    Start sending messages.
    If the message “switch” is entered, the program should switch to Receiving mode.
    If the message “quit” is entered, communication should be terminated and the fifo should be closed.

Receiving:

The program’s mode should be set to Receiving if the program checks for the fifo and one already exists.

Once set to Receiving mode the program:

    Waits for the first message to be sent.
    Print all messages received.
    If the keyword “switch” is received, the program should switch to Sending mode.
    If the keyword “quit” is received, the program should be terminated.

 

You will need to change the mode of the named pipe. As usual, use the following commands to get the description:

 <unix prompt> man 2 stat
 <unix prompt> man 2 mkfifo
 <unix prompt> man 2 open
 <unix prompt> man 2 unlink

The number "2" refers to the section of manual pages. If you skip it, then you will not get what you need. You can use "man -a" to see all sections of man pages. If you omit the section, and "-a", only one entry is shown; the one that is found in the first section (counting up) that contains it.

 
DariusJonesLab3Task3.zip
Nice code structure and output.
 
Question 4
60 / 60 pts
Task 4:
Description/Background:

Your task is to develop a system to stabilize temperature readings:

    The system consists of four external “client” sensors as well as a central “server”.
    Temperatures are passed between the clients and the server by using POSIX message queues.
    The system is stable when all four of the external clients have the same temperature.

Resources/References:

    The lecture notes on POSIX message (Slide 27)
    Avg.zip
    POSIX function reference (Links to an external site.)Links to an external site.
    Linux man reference (Links to an external site.)Links to an external site.

Begin by analyzing the sample code. What does it do?
Your Task:

Implement the functionality defined in the description above in addition to the following:
Reaching Stabilization:

    Each client process sends its temperature to the server process.
    If all of the clients possess the same temperature, the system has reached stabilization and should follow the shutdown procedure listed below.
    The server process will calculate its new temperature based on the formula below.
    The server then sends the new value out to each of the clients.
    Each client then calculates a new temperature based on the formula below.

Calculating Server Temperature:

new_central_temp = (2 * central_temp + sum_of_four_temps_received_from_external_processes) / 6;

Calculating Client Temperature:

new_external_temp = (myTemp * 3 + 2 * central_temp) / 5;

Message Format:

The following struct is recommended for messages:

typedef struct message {

  long type; // a.k.a. priority

  int pid;

  int temp;

  int stable;

} MESSAGE;

MESSAGE msgp;

Mailbox Creation:

Each process will create a mailbox with the id X + i, where i is the numeric identifier of the external process 1..4 or 0 for the central process. For example with X equalling 70:

    The server process would receive messages in mailbox 70, and send its replies to mailboxes 71-74.
    Client process 2 would receive in mailbox 72 and send to mailbox 70 and so forth.
    Thus each client process will attach to two mailboxes and the central process will attach to five.
    If each process specifies IPC_CREAT when invoking msgget(), the first process that invokes msgget() actually creates the mailbox
    subsequent calls to msgget() attach to the existing mailbox.

Message Sending and Receiving:

Assuming the msqid has been established, examples of msgsnd() and msgrev () appear as such:

int stat, msqid;

stat = msgsnd(msqid, &msgp, sizeof(msgp) - sizeof(long) , 0);

stat = msgrev(msqid, &msgp, sizeof (msgp) - sizeof (long) , DEFAULT_TYPE, 0);

Mailbox Deletion:

    Once a process is finished using a message queue, the queue must be removed so that it can be reused by other processes.
    Unless it is removed, the message queue - and any messages that have not yet been received - will remain in the storage space that has been provided for this mailbox by the kernel.
    To remove the message queue, and delete any unread messages therein, it is necessary to invoke msgctl(), as follows:

   struct msgid_ds dummyParam;

   status = msgctl(msqid, IPC_RMID, &dummyParam);

Command Line Parameters:

    Each external process will be uniquely identified by a command-line parameter.
    The first parameter to each external process will be its initial temperature, and the second parameter will be its unique number: 1, 2, 3, or 4.
    The central server will be passed one parameter - its initial temperature.
    Assuming the executable name of the external process is external and the central server is central, invoking all five processes will be done as follows:

   > ./external 100 1 &

   > ./external 22 2 &

   > ./external 50 3 &

   > ./external 40 4 &

   > ./central 60 &

The "&" at the end of the command is used to spawn a child process that executes the command and detach it from the shell, so it can run on its own; even after the shell is terminated. You can get the list of such processes started from a Bash shell using a builtin:

> jobs

NOTE

The ipcs command lists the msqid of all message queues on the system. Use ipcrm to remove message queues according to their msqid. For example, if msqid 163845 appears with the output of ipcs, it can be deleted with the following command:

> ipcrm -q 163845

Required Headers:

All programs should include the following three header files, which are found in /usr/include/sys: ipc.h, types.h, and msg.h.

Lab 04 
 Question 1
20 / 20 pts
The Task:

    Download the code in the creationEfficiency.zip file.
    Modify the code so that you can compare the average creation time of threads vs forks.
    Run the code multiple times, and write a commentary on the results.
    To compile with the pthread library use the following command:

    $ gcc creationEfficiency.c -o creationEfficiency -lpthread
    To get time to under a second accuracy you might want to use gettimeofday().

Useful Resources on Threads:

    http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html (Links to an external site.)Links to an external site.
    https://computing.llnl.gov/tutorials/pthreads (Links to an external site.)Links to an external site.

 
DariusJonesLab4Task1.zip
 
Question 2
40 / 40 pts
Background:

Matrix operations are fundamental tools in Computer Graphics. CG objects can be represented as sets of vertices (n-tupples; usually n is 4; take a CG class to find out why), and can be transformed through a concatenation of matrix operations. Matrix multiplication is the most common operation that is repeated millions of times when the object passes through the geometric pipeline. For efficiency, many of the operations are done in parallel. Usually, that is done by hardware on the video card, but this exercise you will get a taste of it using threads. Given a good scheduling algorithm, and a number of processors, the code can be run very efficiently.
Your Task:

    Implement a multithreaded program to multiply matrices.
    Each thread computes a value for an index (i,j) of the resulting matrix.
    As a parameter to the thread you should pass a pointer to the following structure:

    struct v { int i; int j; };

    For a matrix A of size M x K multiplied by matrix B of size K x N, then M x N multiply threads must be created for computing the resulting matrix C of size M x N.
    Do NOT to use thread_join after the creation of each thread or there will be no concurrency.

Input:

    The first line consists of "m k n"
    m lines of k numbers (Matrix A).
    k lines of n numbers (Matrix B).

Note that the program should check the validity of m k and n so that they can be multiplied together.
Sample Input:

3 2 3
1 4
2 5
3 6
8 7 6
5 4 3
Sample Output:

MATRIX A
1 4
2 5
3 6

MATRIX B
8 7 6
5 4 3

MATRIX A x B
28 23 18
41 34 27
54 45 36

You must use the following specifications for this iteration of implementation.

#define MAX_SIZE 1024

int a[MAX_SIZE][MAX_SIZE], b[MAX_SIZE][MAX_SIZE], c[MAX_SIZE][MAX_SIZE];
int m, k, n;

void *matrixThread(void *cellIndex);
void loadMatrices(char *fileName);
void loadMatrix(FILE *file, int m[][MAX_SIZE], int rows, int cols);
void multiply(int a[][MAX_SIZE], int b[][MAX_SIZE], int c[][MAX_SIZE], int m, int k, int n);
void displayMatrix(int m[][MAX_SIZE], int rows, int cols);
DariusJonesLab4Task2.zip
 
Question 3
20 / 20 pts

 

Implement thread-based matrix multiplication using dynamically allocated arrays.

The following snippet shows declarations and function signatures that you must use:


int **a, **b, **c;
int m, k, n;

void *matrixThread(void *cellIndices);
void allocateAndLoadMatrices(char *fileName);
void loadMatrix(FILE *file, int ***m, int rows, int cols);
void multiply(int **a, int **b, int c**, int m, int k, int n);
void displayMatrix(int **m, int rows, int cols);
DariusJonesLab4Task3.zip
 
Question 4
20 / 20 pts

Implement thread-based matrix multiplication with no global variables. In this solution, one could multiply any number of pairs of matrices concurrently.

The following snippet shows declarations and function signatures that you must use:

void *matrixThread(void *matrixCell);
void allocateAndLoadMatrices(char *fileName, int ***a, int ***b, int ***c, int *m, int *k, int *n);
void loadMatrix(FILE *file, int ***matrix, int rows, int cols);
pthread_t **alloc_tids(int rows, int cols);
void free_tids(pthread_t **threads, int rows);
pthread_t **multiply(int **a, int**b, int**c, int m, int k, int n);
void displayMatrix(int **matrix, int rows, int cols);

struct matrixCell
{
    int i;
    int j;
    int k;
    int **a;
    int **b;
    int **c;
};

int main(int argc, char *argv[])
{   
   int **a, **b, **c; // matrices
   int m, k, n; // dimensions of the matrices m x k and k x m

// process argument list

   allocateAndLoadMatrices(argv[1], &a, &b, &c, &m, &k, &n);

// the rest of main

}


Lab 05 

 Question 1
15 / 15 pts
Overview

For this task you will be implementing a program that performs exponential averaging on a sequence of integers. Each integer represents a CPU burst, or the amount of work that a process needs done.
Input:

Input is provided through the standard input.

Input consists of the following:

    A value for alpha, a float between 0 and 1.
    A sequence of integers separated by whitespace.

Example Input File:

.5
2 6 4 8 5 8 7
Output

The output of the program should consist of the current burst followed by the computed average (Tau0, Tau1,...)

Assume Tau0 to be the same as the first burst.
Example Run:

Please enter alpha value: 0.5 2 6 4 8 5 8 7
Burst 0 is: 2
Tau 0 is: 2.00
Burst 1 is: 6
Tau 1 is: 4.00
Burst 2 is: 4
Tau 2 is: 4.00
Burst 3 is: 8
Tau 3 is: 6.00
Burst 4 is: 5
Tau 4 is: 5.50
Burst 5 is: 8
Tau 5 is: 6.75
Burst 6 is: 7
Tau 6 is: 6.88
Important Note

You may find it useful to use input redirection for this lab:

./avg < input.txt

In this way, you can create repeatable substantial input data streams without the need to write file operations in the code.

The content of input.txt will be input into the program as if it was typed from the keyboard.
DariusJonesLab5Task1.zip
 
Question 2
13 / 15 pts
Overview

In order to gain insight into different scheduling algorithms, you will be implementing a multithreaded "Completion Tester".

You will be testing threads with three different priorities with three corresponding scheduling schemes:
Priority 	Scheduling Scheme
High 	Round Robin (RR)
Medium 	FIFO (FCFS)
Low 	Default Scheduling

Priority is defined through the following enum:

typedef enum {
PRIORITY_HIGH = 99,
PRIORITY_MEDIUM = 50,
PRIORITY_LOW = 1
} PRIORITY;

In order to properly set the thread scheduling properties you will need to use code similar to that seen in the lecture:

pthread_t tid;
pthread_attr_t attr;

// get the default attributes
pthread_attr_init(&attr);

// specialize attributes
struct sched_param schedparam;
schedparam.sched_priority = PRIORITY;

pthread_attr_setscope(&attr, PTHREAD_SCOPE_PROCESS);
pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
pthread_attr_setschedpolicy(&attr, SCHED_RR);
pthread_attr_setschedparam(&attr, &schedparam);
pthread_create(&tid, &attr, &runner, &argv);
pthread_join(tid, NULL);
pthread_attr_destroy(&attr);

Once the thread scheduling and priority information for all three instances of the thread attributes has been set inside of main, you may proceed to the testing phase of the code.
Testing Phase

You should now have set up three thread attribute instances with:

    priorities,
    the corresponding scheduler to that priority (see the table above),
    any other required information.

You task is now to create equal numbers of threads using these attribute types.
The runner function

Each thread does the same thing, but using different scheduling algorithms causes thread activation (i.e., active processing of threads instructions on the CPU) to occur at different rates.

All the thread needs to do is repeat the following until main exits:

    Iterate down from a large number (print nothing here, just busy work for the thread to do).
    When the iteration reaches zero, print out the process id and the priority on a new line. (A string representing the priority should be passed as the runner function parameter).

Note

When exit is called from main it exits the main process and any threads that process has created. You don't have to implement any thread behavior of waiting for the main to finish.
Main

All main needs to do after the creation of the threads is wait for 'q' (quit) to be entered and then exit. This can be accomplished by the following:

while (getchar() != 'q')
{
   sleep(1);
}
exit(0);
Run Setup

You may need to use the following commands in order to get your program working properly:

Switch to root user:

$ sudo su

Change the hard ceiling for the "real-time" priority limit to 99:

# ulimit -Hr 99

Actually change the "real-time" priority limit itself to 99:

# ulimit -Sr 99

Similarly, change the hard ceiling for scheduling priority limit to 99:

# ulimit -He 99

Change the scheduling priority limit itself to 99:

# ulimit -Se 99

Then run your program:

# ./l5t2
Submission

The following must be provided in your submission:

    thread_test.c
    typescript.txt (Under 1 MB please)
    commentary.txt:
        What patterns did you see in the countdown completion rates?
        Is this what you expected?

DariusJonesLab5Task2.zip
You weren't supposed to join the threads nor print stuff all the time, this is what caused what you were explaining in the commentary probably -2
 
Question 3
60 / 70 pts
Your Task:

Today you be implementing a CPU Scheduling Simulator.
Input Criteria:

Read the input from a text file consisting of the format:

    The first line will consist of an identifier for the type of scheduling you will be using. The options are:
        FCFS
        SJF
        SRTF
        RR
    Note that RR (Round Robin) also comes with a time quantum on its first line.
    Each following line will consist of the following process information:
        The process arrival time
        The process burst time

Sample Input:

RR 10
P1 0 15
P2 2 6
P3 5 2
Output Criteria:

The output will show all CPU events in the following format:

    Time tick at which the event happens.
    Which process is executing in the CPU.
    The processes, and their information, in the waiting queue.

The last line of output should show the average waiting time with 2 places after the dot accuracy.
Sample Output:

T0:
CPU: P1(15)
QUEUE: <empty>

T2:
CPU: P1(13)
QUEUE: P2(6)

T5:
CPU: P1(10)
QUEUE: P2(6) P3(2)

T10:
CPU: P2(6)
QUEUE: P3(2) P1(5)

T16:
CPU: P3(2)
QUEUE: P1(5)

T18:
CPU: P1(5)
QUEUE: <empty>

T23:
CPU: <idle>
QUEUE: <empty>

AVERAGE WAITING TIME: 9.00
Additional Notes:

Implement your program in such a way that the scheduling algorithm just selects which process should worked on, while the main actually decremements the work needed to be done.


Lab 06 

 Question 1
10 / 10 pts

    The philoBase.cPreview the document file is an implementation of the dining philosophers paradigm. Analyze the code. Do you see any problems with the code?
    Compile and run the code a number of times. Do you observe any problematic behavior?
    Experiment with some larger numbers for the number of seats and the number of rounds.
    Add the following line between the locking requests for chopsticks:

    usleep(DELAY*2);

    Add a similar line between the calls to return the chopsticks:

    usleep(DELAY*4);
    Compile the code and run again numerous times. Experiment with the numbers. What do you observe now? 



DariusJonesLab6Task1.zip
 
Question 2
30 / 30 pts

Implement the Dining Philosophers model that addresses the issues with the possibility of a deadlock.

There are a number of approaches to do that.

One is to utilize pthread_mutex_trylock() with spinning. That implies using some sort of logic in which both chopsticks are attempted. If only one is available, then the other must be returned, so no deadlock occurs.

Taking the code from the previous exercise as a starting point, implement that solution.
DariusJonesLab6Task2.zip
I'm not sure this always prevents a deadlock, not the approach I was looking for
 
Question 3
60 / 60 pts

Implement a solution to the Dining Philosophers problem using the pthread library's mutex and conditional variable functions.

Recall the pseudocode from the lecture notes:

monitor DiningPhilisophers {
  enum { THINKING; HUNGRY; EATING} state[5];
  condition self[5];
  void pickup (int i) {
    state[i] = HUNGRY;
    test(i);
    if (state[i] != EATING)
      self[i].wait();
  }
  void putdown (int i) {
    state[i] = THINKING;
    // test left and right neighbors
    test((i + 4) % 5);
    test((i + 1) % 5);
  }
  void test (int i) {
    if ( (state[(i + 4) % 5] != EATING) && (state[i] == HUNGRY) && (state[(i + 1) % 5] != EATING) ) {
      state[i] = EATING ;
      self[i].signal();
    }
  }
  initialization_code() {
    for (int i = 0; i < 5; i++)
    state[i] = THINKING;
  }
}

C does not provide monitors, so you need to implement them. A monitor synchronizes execution of its member functions, so only one function can be executing at any given time. The same effect can be achieved with pthread mutexes. The following is a pseudocode that adds a C function to a virtual monitor defined by a mutex:

function()
{
  wait(monitor_mutex);
...
// body of the function
...
  signal(monitor_mutex);
}

You will need just one monitor for this assignment, so just one mutex is sufficient for all functions.

Note that a conditional variable must be associated with a mutex. It will be an error to call wait or signal on a conditional variable from outside of a critical section protected by the associated mutex.

Also, you can allocate a mutex statically in the following way:

pthread_mutex_t monitor_mutex = PTHREAD_MUTEX_INITIALIZER;

Note furthermore, that trying to lock the same lock twice blocks the thread.

With the pickup() and putdown() functions synchronized with a monitor, each philosopher is a thread using the following template:

...
pickup(i);
// EAT
putdown(i);
...

Generate a random number and use it in a delay in lieu of the eating time.

NOTE: Your implementation MUST follow this guideline.

Lab 07 
 Question 1
95 / 100 pts
Overview:

For this task we will be needing to detect a cycle within a resource dependency graph.

We will be representing a graph on N vertices using an adjacency matrix.

An adjacency matrix is a two-dimensional array in which:

    both rows and columns represent graph vertices, and
    the values at intersections of rows and columns represent graph edges.

An adjacency matrix for an unweighted directed graph (such as a resource dependency graph) can have two values at each of the cells indexed by row i and column j:

    0: representing that vertex i is not connected to vertex j, and
    1: representing that there is a connection between vertex i and vertex j.

Note: that in a directed graph an edge starting at vertex i and ending at vertex j does not guarantee that there is an edge in the opposite direction; i.e., starting at vertex j and ending at vertex j
Input and Output:

You will need to implement a system for reading from the input the following types of commands (more details in the following sections as the user enters them):

    Add vertex
    Add edge
    Remove edge
    Display adjacency matrix
    Check for deadlock
    Help
    Quit

Add Vertex:

Adds a new named vertex into the graph.

Example Input:

add vertex Aaa

Corresponding Output:

Added a new vertex named Aaa at index <vertex_index>.

Possible Errors:

There is already a vertex with the name <vertex_name>.

The maximum limit of vertices (20) has been already reached.
Add Edge:

Creates a directed edge between two named vertices.

Example Input:

add edge Aaa Bbbb

Corresponding Output:

Added an edge from vertex Aaa to vertex Bbbb.

Possible Errors:

That edge already exists.

One or more of those vertices does not exist.

A vertex cannot be connected to itself.
Remove Edge:

Remove a directed edge between two named vertices.

Example Input:

remove edge Aaa Bbbb

Corresponding Output:

Removed the edge from vertex Aaa to vertex Bbbb.

Possible Errors:

No edge exists between those two vertices.

One or more of those vertices do not exist.
Display Adjacency Matrix:

Displays the adjacency matrix for the vertices and edges that currently exist within the graph.

Example Input:

display

Example Output from the sample run:

              Aa       Bbb      Cccc     Ddddd
    Aa         0         0         1         1
   Bbb         0         0         1         0
  Cccc         0         1         0         1
 Ddddd         1         0         1         0

Possible Errors:

Unable to display adjacency matrix. There are no vertices yet.
Check For Deadlock:

Checks whether a cycle exists, and therefore whether this would cause a deadlock.

Example Input:

check

Corresponding Output:

~~~ DEADLOCK (Cycle Exists) ~~~

OR

~~~ NO DEADLOCK (No Cycle Exists) ~~~
Quit:

Exits the program

Example Input:

quit

Corresponding Output:

Exiting the program.
Help:

Displays a list of the possible commands.

Example Input:

help

Example Output:

The following commands are available for use:
    add vertex <vertex_name>
    add edge <from_vertex_name> <to_vertex_name> 
    remove edge <from_vertex_name> <to_vertex_name> 
    display
    check
    help
    quit
Angled brackets such as: <info> represent user defined information.

Example Skeleton:

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>

#define STRING_MAX_SIZE 50
#define MAX_NUMBER_OF_VERTICES 20

char *vertex_names[MAX_NUMBER_OF_VERTICES];
bool adjacency_matrix[MAX_NUMBER_OF_VERTICES][MAX_NUMBER_OF_VERTICES];
int number_of_vertices = 0;

int get_index_of_vertex(char *vertex_name);
void add_vertex(char *vertex_name);
void add_edge(char *from_vertex_name, char *to_vertex_name);
void remove_edge(char *from_vertex_name, char *to_vertex_name);
void display_adjacency_matrix();
bool check_for_cycle();
void display_help();
void free_names();

int main(int argc, char *argv[])
{

}

Sample Run:

Enter a command: display
Unable to display adjacency matrix. There are no vertices yet.
Enter a command: help
The following commands are available for use:
    add vertex <vertex_name>
    add edge <from_vertex_name> <to_vertex_name> 
    remove edge <from_vertex_name> <to_vertex_name> 
    display
    check
    help
    quit
Angled brackets such as: <info> represent user defined information.
Enter a command: add vertex Aa
Added a new vertex named Aa at index 0
Enter a command: add vertex Aa
There already exists a vertex with the name: Aa
Enter a command: add vertex Bbb
Added a new vertex named Bbb at index 1
Enter a command: display
                  Aa       Bbb
        Aa         0         0
       Bbb         0         0
Enter a command: add vertex Cccc
Added a new vertex named Cccc at index 2
Enter a command: add vertex Ddddd
Added a new vertex named Ddddd at index 3
Enter a command: add edge Aa Aa
A vertex cannot be connected to itself.
Enter a command: add edge Aa Xyz
One or more of those vertices does not exist.
Enter a command: add edge Aa Bbb
Added an edge from vertex Aa to vertex Bbb.
Enter a command: display
                  Aa       Bbb      Cccc     Ddddd
        Aa         0         1         0         0
       Bbb         0         0         0         0
      Cccc         0         0         0         0
     Ddddd         0         0         0         0
Enter a command: check
>> NO DEADLOCK <<
Enter a command: add edge Bbb Cccc
Added an edge from vertex Bbb to vertex Cccc.
Enter a command: add edge Cccc Ddddd
Added an edge from vertex Cccc to vertex Ddddd.
Enter a command: display
                  Aa       Bbb      Cccc     Ddddd
        Aa         0         1         0         0
       Bbb         0         0         1         0
      Cccc         0         0         0         1
     Ddddd         0         0         0         0
Enter a command: check
>> NO DEADLOCK <<
Enter a command: add edge Ddddd Aa
Added an edge from vertex Ddddd to vertex Aa.
Enter a command: display 
                  Aa       Bbb      Cccc     Ddddd
        Aa         0         1         0         0
       Bbb         0         0         1         0
      Cccc         0         0         0         1
     Ddddd         1         0         0         0
Enter a command: check
>> DEADLOCKED <<
Enter a command: remove edge Ddddd Aa
Removed the edge from vertex Ddddd to vertex Aa.
Enter a command: display
                  Aa       Bbb      Cccc     Ddddd
        Aa         0         1         0         0
       Bbb         0         0         1         0
      Cccc         0         0         0         1
     Ddddd         0         0         0         0
Enter a command: check
>> NO DEADLOCK <<
Enter a command: quit
Exiting the program.

DariusJonesLab7Task1.zip
Some of your messages are off for adding edges as well as allowing edges to connect to nonexistent vertices -5. 

Lab 08 


Question 1
10 / 10 pts

The statLibExmpl.zip file contains an implementation of a trivial application. Compile the files the usual way and run the application:

$ gcc *.c -o testNoLib
$./testNoLib

Next, create a static library libgiveMeNum.a as follows:

$ gcc -c giveMeNum.c -o giveMeNum.o
$ ar rcs libgiveMeNum.a giveMeNum.o

Verify that the library has been created and that it contains giveMeNum() function:

$ nm libgiveMeNum.a

If you just want to see which *.o files are included, you can use:

$ ar t libgiveMeNum.a

Note that 'ar' is an archiver that adds files to the library. If you switch between Linux and Mac OS X, then you may end up with two versions of giveMeNum.o in the library; that can be a problem, since the linker will use the first version that it finds in the archive. Therefore, the safest approach is to remove the previous version of libgiveMeNum.a. In general, you need to keep in mind that the order in which libraries are appended to the linker is important, since it changes the order in which symbols are searched.

Now, create the application again using the static library:

$ gcc testStatLibMain.c -L. -lgiveMeNum -o testStatLib

'-L.' option adds the current directory ('.') to the library search for gcc, and '-lgiveMeNum' advices the linker to include the static library libgiveMeNum.a to the application. Note the change in the name.

Verify that in spite of being built differently the application runs as before.

$ ./testStatLib

Although this is explicit invocation of a compiler only, under the hood, also a linker is invoked implicitly after a successful compilation. You can see the details of the process by using the 'verbose' option of gcc. Try it out:

$ gcc -v *.c

Submit a log of your session that shows all your exercises. It should include all described commands.
DariusJonesLab8Task1.zip
 
Question 2
10 / 10 pts

The dynLibExml.zip file contains an implementation of a trivial application that uses a dynamic library. Download the files, compile the way we did it in the past, and then try to run. Can you? Provide commentary.

Now, create a dynamic library from giveMeNum.c:

$ gcc -fPIC -shared -nostartfiles -o libgiveMeNum.so giveMeNum.c

Then, compile the main program for the use with the dynamic library:

$ gcc -rdynamic -o testDyLibMain testDyLibMain.c -ldl

Note that the order of parameters for gcc is important.

As with static libraries, you can verify that the library has been created and that it contains giveMeNum() function:

$ nm libgiveMeNum.so

You can use "objdump" or "readelf" to explore the libraries. Use man pages to find out more.

Submit a log from the session in which you followed all instructions from this exercise including exploring the contents of the library.



DariusJonesLab8Task2.zip
 
Question 3
54 / 60 pts

Create a static library that provides the functionality of the Inverted Page Table. Assume that:

void initInverted(struct invTablePage **invTable, int memSize, int frameSize);
/*
* allocates and initializes the table for the given sizes of the memory and frame
* to ensure that the library is thread-safe, the table should be a struct that
* includes metadata such as page size and the number of pages along the translation
* table (that can be a 2-dimensional array, or a one-dimensional array of structs)
*/

int translate(struct invTablePage *invTable, int pid, int page, int offset)
/*
* translates a logical address <pid, page, offset> into a physical address
* if the address is invlid it returns -1
* if there is no entry for the pid and the page number in the table, it has to be added
* if there is no room in the table for the new entry, then the oldest entry has to be removed
*/

void releaseInverted(struct invTablePage **invTable);
/*
* releases the inverted table and sets the reference to NULL
*/

Write a test program that generates random addresses (i.e., <pid, page, offset>) and uses the library to translate them into physical equivalents.

Note that the system has to work as a cache: you need a data representation that tags the elements of the table. One idea is to time-stamp the entries when they are accessed (including the initial access after the page is added to the table). When a reference is made to a page, a free frame is located and an entry mapping the process and the page to the frame is inserted into the table at the position corresponding to that frame along with a tag. Subsequently, each time the page is referenced, the time tag for the entry corresponding to that page in the table must be updated. If there is no free frame available ("page fault"), then the oldest entry in the table should be released and replaced by the currently needed page (along with a tag, of course).

Submit all the source code files, output from your test program, a log from the compilation session, and a log from the testing session.
DariusJonesLab8Task3.zip
I do not see any evidence of this being compiled as a static library -10%
 
Question 4
20 / 20 pts

Create a dynamic version of the inverted table library.

Modify the test program from the previous task, so it uses the dynamic rather than static version of the library.

Please note that the code will not compile with a dynamic library unless you instruct gcc to use it (same as with the static libraries). For example:

gcc -rdynamic -o testDyLibMain testDyLibMain.c -L. -lgiveMeNum -ldl

Submit all the source code files, output from your program, a log from the compilation session, and a log from the testing session.

Lab 09 

 Question 1
10 / 10 pts

Compile and run the code tin memoryMappedFile.cPreview the document. Use a medium size text file (let's say 20kB or so); text is for convenience of seeing the content in prints. Then, answer the following questions:

    What is the page size that your operating system is using?
    What is the valid scope for the first offset reference to the content of the file?
    Why does the program crash for some values of offset?
    For what values of the offset, the program does not crash?

Read the man page for mmap. Then, change the code, so after printing the character at the offset, it is substituted with a character from the standard input. After the substitution, the code should print the character at the offset (from the file, and not from the input) once more. Hint: Pay attention to the permission mode with which the file is opened and mapped.

 
DariusJonesLab9Task1.zip
 
Question 2
35 / 35 pts
Overview

For this task you will implement the Least Recently Used (LRU) page replacement algorithm using a page table based on a stack implemented as a double-linked list. The program will be fed with a sequence of page references and its output will be the corresponding page fault rate for a given maximum capacity of the table.
The Table

You are required to implement the table as a quasi-stack made up of double-linked nodes (as discussed in the lecture). This means that each node has a pointers to its next and its previous neighbors, as well the corresponding number of the referenced page.

Initially, the table does not have any pages (it is an empty list). As pages are being referenced, new nodes representing the referenced pages are being pushed on the stack until the list reaches its maximum capacity (given as an input parameter). When the list is at its maximum capacity, then there are two cases to consider:

    When the referenced page is not in the table, it is placed at the top of the stack and the node from the bottom of the stack (representing the victim page) is removed.
    When the referenced page is already in the table, the node corresponding to that page must be moved to the top of the stack.

Since removal of an element other than the top of a stack is not a standard stack behavior, we refer to the structure used in this task as a quasi-stack.
Input

The input will consist of the following components:

    List maximum capacity.
    A sequence of page references.

Number of frames

The list maximum capacity determines the number of frames in the reference table; i.e., the number of page references that can be kept at any given moment.
A sequence of page references

The sequence of page references is a list of numbers that correspond to referenced pages. Each page number is a non-negative integer. The length of the list must be a positive integer (i.e., an integer greater than 0).
Example Input

3
7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1
Output

For every request within the list of references the following components must be displayed:

    The reference table before the request
        The table is displayed in the order of the stack
    The request
    Whether there was a hit or a fault
        Hit: The reference was already in the table
        Fault: The reference was not in the table and needed to be inserted.
    The reference table after the request

Once the entire list of references has been processed, the number of faults should be displayed.
Example Output

(corresponding to the example input)

*7
*0 7
*1 0 7
*2 1 0
>0 2 1
*3 0 2
>0 3 2
*4 0 3
*2 4 0
*3 2 4
*0 3 2
>3 0 2
>2 3 0
*1 2 3
>2 1 3
*0 2 1
>1 0 2
*7 1 0
>0 7 1
>1 0 7

Number of faults: 12

Notes: The top of the stack is on the left, and the bottom is on the right. The * indicates a page fault, and > indicates referencing a page that was already in the table and that was moved to the top.
Submission:

You will need to submit the following:

    replace.c containing your task code
    typescript.txt containing several runs with different page reference sequences.


Project 01 

 Question 1
20 / 20 pts

Implement in C an in-memory file system simulator with a flat linear directory structure and a direct and indexed space allocation. You will need:

    a storage that is an array of 2^16 blocks of 256 bytes each; a block is just a plain sequence of bytes until it is overlaid with a structure (use a union, of course): directory or file meta-data, an index node, or a data node; there is also a type of the node:

    #define BLOCK_SIZE 256
    #define MAX_NAME_LENGTH 128
    #define DATA_SIZE 254
    #define INDEX_SIZE 127

    typedef char data_t;
    typedef unsigned short index_t;

    typedef enum
    {
       DIR,
       FILE,
       INDEX,
       DATA
    } NODE_TYPE;

    typedef struct fs_node
    {
       char name[MAX_NAME_LENGTH];
       time_t creat_t; // creation time
       time_t access_t; // last access
       time_t mod_t; // last modification
       mode_t access; // access rights for the file
       unsigned short owner; // owner ID
       unsigned short size;
       index_t block_ref; // reference to the data or index block
    } FS_NODE;

    typedef struct node
    {
       NODE_TYPE type;
       union
       {
          FS_NODE fd;
          data_t data[DATA_SIZE];
          index_t index[INDEX_SIZE];
       } content;
    } NODE;

    // storage blocks

    NODE *memory; // allocate 2^16 blocks (in init)
    a superblock kept in the first block of the storage. That block of the directory type is the root directory of the file system. It's name should be just "/". The creation time should be 0, the owner should be "none", the size shoud be initially 0, and the access should not allow for deletion or name change. The block reference variable can point only to an index node, and not data block. The superblock should be set up during the file system initialization. NOTE: In principle, this block could also hold the details of the file system such as the block size and the number of blocks, but you can use the constants in this implementaton.
    a bit vector for managing free space; one bit should represent each block in the storage. This is a bit vector, so you should use bit-wise operations in the implementation.

    // bit vector

    char *bitvector; // allocate space for managing 2^16 blocks (in init)

A file-descriptor node holds meta-data information about a file or a directory such as size, access rights, creation time, access time, and modification time, along with a pointer to actual content of the file or directory.

In case of a node with the type of directory, the size indicates the number of files in the directory, and the block reference points to the index block that holds indices to all files in the directory. Assume that a directory may hold directly up to 127 files or directories; each index of the index block points to a file or a directory descriptor. Of course, each of the subdirectries may hold another 127 files or directories, and so on.

In case of a file, the size in the file descriptor indicates the actual size of the file. The block reference either points to a single data block if the size of the file is less than 254, or to an index block with an array of references to data blocks for files larger than 254. Assume that the maximum size of a file is 127 * 254 (i.e., maximum allowed for a one-level indexing).

Implement functions to:

    create the file system (i.e., allocate and initializing all structures and auxiliary data; create the superblock)
    create a file (i.e., allocate one block for meta-level information; set the size to 0, the times to the current time, and the access rights to some arbitrary default)
    create a directory (just like a file creation, but with a different node type)
    delete a file (return blocks and clean up your supporting structures; e.g., reset the bits in the bit vector)
    delete a directory (delete the files from the directory, and then delete the directory; clean up)
    obtain file information (type - file or directory, size, times, access right, owner)

Please do not jump ahead of things: You will work on file operations like open(), read(), write(), etc., in the next installments of the assignment; do not worry about that for now; instead focus on managing the meta-data of files.

In the submission of your code, logs, test runs, etc., do not forget to provide a detailed commentary on your design choices.
DariusJonesProject1Task1.zip
 
Question 2
16 / 20 pts

The assumption is that by now you have a file system with a basic structure, directory, free space bitvector, and functions to create a file system, create a file, delete a file, create a directory, delete a directory, and list file information.

In this installment, you will be working on opening a file, reading from a file, and writing to a file. Please review the lecture notes to refresh your knowledge about the techniques used in OSes.

In particular, you should implement:

    global open file table
    per process file table
    open() function
    read() function
    write() function
    close() function

Recall that when a file is read, then frequently used elements of it's FCB (file control block) are loaded into the main memory to improve efficiency (accesing the memory is a magnitude of order faster than accessing a disk). Usually there is a table of all open files, and a table of files opened by a specifc process. You should distribute the information between the two tables; for example, the main table can keep the information about the location of the file, and the tables local to processes can keep specifics such as the access rights.

The global table implementation should use hashing for searches. Use 65551 (prime number!) as the size of the table. Do not forget about implementing the collision resolution mechanism! Describe your choices thoroughly.

You can use any hash function (COMP151?); you may try these as well:

    http://en.wikipedia.org/wiki/Hash_function (Links to an external site.)Links to an external site.
    http://burtleburtle.net/bob/hash/doobs.html (Links to an external site.)Links to an external site.
    http://www.cse.yorku.ca/~oz/hash.html (Links to an external site.)Links to an external site.

Keep in mind that some files can be opened just for reading, so your open() function must have a parameter for this. The write() function has to check the mode of the opened file, so read-only files are not overwritten.

Be careful with processes calling close() function. If another process has the same file opened, you cannot remove the FCB from the global open file table; hence you need a reference count.

When you open a file, you can use a system default for allocating some predefined space; or, you can just allocate the file descriptor node and postpone allocating more when a write is requested. When file grows, you can have another configuration option that states by how much the file should grow. 

Remember that directories are just special files, so they can be opened in the same way.

You do not have to implement caching.

The following are data structures supporting this design:


// global table

typedef struct open_file_global_type // elements of the hash table (in-memory "directory")
{
   unsigned short fd; // reference to the file descriptor node
   unsigned short data; // reference to the data or index node (depending on the size)
   mode_t access; // access rights for the file
   unsigned short size; // size of the file
   unsigned short reference_count; // reference count
   struct open_file_global_type *next;
} OPEN_FILE_GLOBAL_TYPE;

#define GLOBAL_TABLE_SIZE 65521 // prime number for hashing
OPEN_FILE_GLOBAL_TABLE global_table[GLOBAL_TABLE_SIZE];

// local table

typedef struct open_file_local_type // a node for a local list of open files (per process)
{
   mode_t access_rights; // access rights for this process
   unsigned_short global_ref; // reference to the entry for the file in the global table
} OPEN_FILE_LOCAL_TYPE;

#define MAX_OPEN_FILES_PER_PROCESS 16
OPEN_FILE_LOCAL_TYPE local_table[MAX_OPEN_FILES_PER_PROCESS];

NOTE: You will be able to test multiprocess environment when you integrate your implementation with FUSE. For example, you will be able to open two terminal sessions (Terminal) and edit (vi, emacs, Smultron, Textedit, etc.) the files in your file system. In fact, that's how I am going to test your implementation.

NOTE: Please note that to implement properly per-process table and file access rights, you will need process id of the process that is accessing the data. Ultimately, you will get that from FUSE, but in this task, just simulate it.
DariusJonesProject1Task2.zip
Mostly there
 
Question 3
10 / 10 pts
Please click on the following link with the FUSE tutorial proj1s1.html (it is too long for Canvas to accept) and follow all the steps.
DariusJonesProject1Task3.zip
 
Question 4
15 / 15 pts

Taking hellofs-ubuntu.c from the tutorial from task 1 as the starting point, write a file system that has several files:

    the original /hello
    another file that has a different name and content
    a third file that is displayable in the directory list but unreadable otherwise (you can fake it in hello_open())
    a fourth file that returns random strings of random length (you can fake the size in hello_getattr()).

Submit the code of your file system and a log of a session in which you mount your file system at a mount point called myfs and then run the bash script in the test_myfs.sh file. Please note that you need to make the file executable; recall from the lecture notes how to do that.
DariusJonesProject1Task4.zip
 
UnansweredQuestion 5
0 / 20 pts

Integrate all your work on the file system with FUSE. You may find the singlefs.cPreview the document file useful. It uses a single file file system, but lists many of the FUSE operations that you will need. Keep in mind that FUSE can be run in a debug mode if started with "-d" command line option as follows:

$ gcc -Wall -g singlefs.c `pkg-config fuse --cflags --libs` -o singlefs
$ mkdir mnt
$ ./singlefs -d mnt

You will see a lot of debugging information printed in the same terminal. You will need another terminal to interact with the file system. Each time you do that, you will see more debug information. Tracing what's going on will help you with figuring out what might be still missing.

You may find the following tutorial that just redirects all requests to a local file system very informative:

http://www.cs.nmsu.edu/~pfeiffer/fuse-tutorial/ (Links to an external site.)Links to an external site.

You may also find studying fusexmp.c interesting:

http://lucasvr.gobolinux.org/etc/fusexmp.c (Links to an external site.)Links to an external site.

as it similarly implements a FUSE file system out of calls to the regular VFS (using standard UNIX system calls).

Here is a link to a page of FUSE documentation (Links to an external site.)Links to an external site. maintained by prof. Geoff Kuenning (Links to an external site.)Links to an external site. at Harvey Mudd College. You can find in there many interesting details including how to debug the file system code (how to run the file system in gdb) and also how to get the process id of the process making a request by querying fuse context:

pid_t process_id = fuse_get_context().pid;

Please refer to the following page to examine further details of struct fuse_context that is returned by the function:

http://libfuse.github.io/doxygen/ (Links to an external site.)Links to an external site.

Submit the code and a log of the test sessions.

Recall that you can capture the session:

http://discuss.itacumens.com/index.php?topic=29823.0;wap2 (Links to an external site.)Links to an external site.

NOTE: Focus strictly on the implementation of the specifications of this project.
 
UnansweredQuestion 6
6.5 / 15 pts
Implement the FUSE support for the hierarchical structure (directories) of the file system. 

Project 02 





